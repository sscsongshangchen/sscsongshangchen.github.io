<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Christian_Song</title>
  <subtitle>与其随波逐流，我更希望以自己的方式度过一天。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-19T07:01:59.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>尚辰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>伽马函数</title>
    <link href="http://yoursite.com/2017/06/19/gamahanshu/"/>
    <id>http://yoursite.com/2017/06/19/gamahanshu/</id>
    <published>2017-06-19T07:00:23.000Z</published>
    <updated>2017-06-19T07:01:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="[http://www.flickering.cn/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/2014/06/%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BC%BD%E7%8E%9B%E5%87%BD%E6%95%B0%E4%B8%8A/]">神奇的伽马函数</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;[http://www.flickering.cn/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/2014/06/%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BC%BD%E7%8E%9B%E5%87%BD%E6
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《机器学习》中的一些符号</title>
    <link href="http://yoursite.com/2017/06/11/somesignsinmaths/"/>
    <id>http://yoursite.com/2017/06/11/somesignsinmaths/</id>
    <published>2017-06-11T03:28:33.000Z</published>
    <updated>2017-06-11T03:35:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，一直在准备数据挖掘实务课程设计，想起之前买的周志华博士的“西瓜书”还没有翻过，就抱着好奇的想法试着读了读，结果看得欲罢不能😆。</p>
<p>其中部分符号读起来有点陌生，列出来参考：</p>
<h1 id="arg-min"><a href="#arg-min" class="headerlink" title="arg min"></a>arg min</h1><p>y = max f(t) 返回最大的f(t)<br>y = arg max f(t) 返回最大的f(t)所对应的t</p>
<h2 id="随时补充"><a href="#随时补充" class="headerlink" title="随时补充"></a>随时补充</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，一直在准备数据挖掘实务课程设计，想起之前买的周志华博士的“西瓜书”还没有翻过，就抱着好奇的想法试着读了读，结果看得欲罢不能😆。&lt;/p&gt;
&lt;p&gt;其中部分符号读起来有点陌生，列出来参考：&lt;/p&gt;
&lt;h1 id=&quot;arg-min&quot;&gt;&lt;a href=&quot;#arg-min&quot; c
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>对之前文章的简介</title>
    <link href="http://yoursite.com/2017/06/09/briefintro/"/>
    <id>http://yoursite.com/2017/06/09/briefintro/</id>
    <published>2017-06-09T03:15:56.000Z</published>
    <updated>2017-06-09T03:32:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>此文之前的数篇文章为过去一段时间学习iOS开发的笔记，原载于简书，现在迁移到自己的blog，不过由于简书使用的是富文本，而博客使用markdown语法，图片需要上传到图床才能正常显示，尔后我会督促自己会慢慢完善修改的。</p>
<p>学习iOS开发，最大的收获不只是做出一个完整功能的APP（备忘清单），还有对OOP的更深入应用，对苹果开发哲学的管窥，这些都直接或间接地帮助我在学习R语言，图形绘制，其他文档阅读有特别迅速的提升。如果你有一台Mac，也有一点点的英文基础，那么就别犹豫了，去探索这一片未知却有趣的天地吧！</p>
<p>大三了，学了不少专业课才意识到统计学才是自己的本专业，而爱过二年的CS，才不会断舍离，计算机和统计学共舞才会演出绝妙的舞姿！</p>
<p><a href="http://www.jianshu.com/u/c6849e05de7e" target="_blank" rel="external">我的简书主页 </a></p>
<p>\<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31517163&auto=1&height=66" \="">\</iframe></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文之前的数篇文章为过去一段时间学习iOS开发的笔记，原载于简书，现在迁移到自己的blog，不过由于简书使用的是富文本，而博客使用markdown语法，图片需要上传到图床才能正常显示，尔后我会督促自己会慢慢完善修改的。&lt;/p&gt;
&lt;p&gt;学习iOS开发，最大的收获不只是做出一个
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 集合类型</title>
    <link href="http://yoursite.com/2017/06/09/ioscollectiontype/"/>
    <id>http://yoursite.com/2017/06/09/ioscollectiontype/</id>
    <published>2017-06-09T03:14:44.000Z</published>
    <updated>2017-06-09T03:15:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>集合类型：<br>Swift，和其他现代编程语言一样，有内置的集合类型数组（Array）和字典（Dictionary），还增加了第三种类型集合（Set）。数组和字典非常重要以至于Swift提供了很多特殊的语法。同时像其他的大部分Swift类型，它也提供了一些相关的的函数；NSArray和NSDictionary也会补充一些丢失的函数。而集合类型则是桥接至Cocoa的NSSet。<br>数组（Array）：<br>数组（结构体）是有序的对象实例的集合（数组的元素），可以使用Int类型的序号来取出元素。而且序号是从0开始的。比如一个数组有四个元素，那么它就是从0到3。Swift的数组是非空的，所以如果有Index3那么就要有0—2.<br>最显著的Swift数组特性是其严格类型检验。不想有些其他的语言，Swift数组的元素必须统一，也就是说，其必须是由确定的一种类型的元素所组成的。即便是空数组也必须要有确定的类型。元素类型不同的两个数组被认为是两种不同的类型，数组类型依照元素类型遵循多态：如果NoisyDog是Dog的子类，那么元素是NoisyDog的数组就可以用在Dog元素数组的地方。哈哈，没错这个和可选值一样也是泛型声明，即Array\<element\>，Element就是元素的类型。<br>事实上数组类型同一限制，可能没有你想象的那么宴客。数组的元素必须是一种类型，但是类型却是十分领会的。通过选择合适的数组类型你可以制作出实际上内部有多种类型的数组，比如：<br>1、如果NoisyDog是Dog的子类，那么Dog的数组就可以包含NoisyDog的元素。<br>2、如果Bird和Insect都采用了Flier协议，Flier为元素的数组就可以包含Bird或者Insect。<br>3、AnyObject元素数组就可以包含任何Swift的类的实例和桥接类的实例，比如Int，String、Dog。<br>4、一种类型可能承载多个类型，比如枚举类型就可以在关联值中有Int、String等等类型。<br>声明数组的类型既可以用泛型声明：Array\<int\>，也可以用语法糖声明：<a href="">Int</a>。后者你会经常使用到。<br>字面数组可以使用包含在方括号中的一系列被逗号分隔的元素来表示，空数组的字面表示形式就是：<a href=""></a>。<br>数组的默认构造器init()，你可以在后面加一对空的圆括号来表示空数组：</int\></element\></p>
<p>1<br>如果引用量类型可以提前知道，那么该空数组可以推迟其类型，因此你也可以这样来创建空数组：</p>
<p>2<br>如果你用非空的字面元素来开始，那么你就不需要声明数组的类型，因为Swift会通过元素类型来推测出数组的类型。比如Swift会推测<a href="">1,2,3</a>为Int数组。如果数组包括父类和子类，那么Swift将会推测其为父类类型数组。甚至<a href="">1, “howdy”</a>这样的数组也是可以的，不过其类型是NSObject。然而在某些情况下，即使你用字面量来声明，你最好也现将引用量的类型显式声明：</p>
<p>3<br>数组也有参数是序列的构造器，这就说明如果是序列类型，你就可以将它分开来充当数组的元素。比如：<br>1、Array(1…3)就能产生Int类型的数组<a href="">1,2,3</a>。<br>2、Array(“hey”.character)就会产生<a href="">“h”, “e”,”y”</a>。<br>3、Array(d) 其中d是字典，就会产生key-value对的元组类型数组。<br>还有一种构造器 init(count:repeatValue:)，可以用来初始化重复值。比如我要初始化一百个nil值在String？数组中。<br>let strings : <a href="">String?</a> = Array(count:100, repeatedValue: nil)<br>这是你在Swift中能得到的最接近于缺失数组的方法：你有100个空位可以放对象。<br>数组转型和类型检查：<br>当你将一个数组分配、传递以及转型到另一个数组的时候，你是在每个元素的层面上去操作的：</p>
<p>4<br>这段代码事实上是简写：将Int类型的数组赋给Int？类型数组，实际上是，每一个原数组中的元素都要进行封包。事实上是这样的情况：</p>
<p>5<br>类似地，假如NoisyDog是Dog的子类，下面的代码是合法的：</p>
<p>6<br>在第三行，我们建立了一个Dog数组。第四行我们将Dog数组转型为NoisyDog数组，这就意味着我们将每个元素分别转为NoisyDog类。<br>你可以用is运算符测试元素类型来测试数组的类型：</p>
<p>7<br>如果每个元素均为NoisyDog，那么结果就是True。<br>同样的，as？运算符将把一个数组转为包在可选值中的数组，如果无法下行转换，结果将是nil。</p>
<p>8<br>数组转型的目的和其他类型的转型是类似的——你可以发送合适的消息给转型后的数组。如果NoisyDog声明了Dog类没有的方法，你就不能向Dog类型的数组发送该方法。这样你就需要将元素转型为NoisyDog，然后编译器才会让你去进行发送方法消息。你既可以将其中的元素进行转型，也可以将整个数组进行转型。<br>数组的比较：<br>如果两个数组元素数一样且全部相等的话，那么就是相等的。</p>
<p>9</p>
<p>10<br>数组是值类型：<br>由于数组是结构体，所以其不是引用类型，而是值类型。这就意味着，每一次数组被分配到变量或者作为函数参数，它都会被复制一份。然而我不是在暗示这种复制的代价很大。如果数组的引用是一个常量，那么显然复制就不是必要的了，甚至从其他数组产生新数组的操作或者转变数组的操作已经是非常高效的了。<br>你只需相信Swift的设计者已经考虑过这个问题，而且在后台处理数组是十分高效的。<br>虽然数组本身是值类型，但是其元素是引用类型的还是按照引用类型来对待。特别是类的实例为元素的数组，如果被多个变量引用。那么就会产生多个引用这一个相同的实例。<br>数组下标：<br>数组结构体利用下标方法允许通过在引用变量后面添加包含值的方括号来取出元素。值可以是Int比如arr<a href="">1</a> 就是取出arr数组的第二个值。值还可以是Int的范围，比如，arr<a href="">1…2</a>就是去取出第二个和第三个值，严格的说，这会产生叫做ArraySlice的东西，其非常类似于Array，比如你可以用和数组一样的下标来取出ArraySlice的元素；而且它也可以用在数组能用的地方。一般地，你就把他当做是数组就可以了。<br>如果数组的引用是可变的（即var，而不是let），那么下标的表达方法也可以用来被分配值。这会改变那个被下标表达元素的值，被分配的值必须是与数组元素的类型一致。</p>
<p>11<br>如果下标是一段区间，那么赋的值就必须是一个数组，这有可能改变数组的长度：</p>
<p>12<br>下标超过应有的范围就会引起运行错误。<br>嵌套数组：<br>数组的元素是数组是合法的。比如：</p>
<p>13<br>它是Int类型数组的数组。它的类型声明是[[Int]()]。（没有规定说，内部的数组必须是相同长度，上面只是为可了便于表达）<br>为了得到内部的数组元素，你可以使用下标链：</p>
<p>14<br>如果外部数组的引用是可变的，你还可以进行写入：</p>
<p>15<br>你可以用其他方法改编内部数组，比如你可以为它添加新的元素。<br>基本数组属性和方法：<br>数组是一个集合(采用CollectionType协议)，而集合又是一个序列（采用SequenceType协议）。如果这些项有熟悉的情景，如同String的characters。从这个方面来看，它与字符序列是很像的。<br>作为集合，数组的count只读属性表示元素的个数。当count为0时候，isEmpty属性就是true。<br>数组的first和last只读属性返回了它的第一个和最后一个元素，但是它们均被可选值包裹，因为数组有可能为空，此时它们的值就是nil。这是在Swift中比较少见的双重可选的情况，比如，当你声明一个类型为Int？的数组的时候，此时如果为nil，那么就是Int？？。<br>数组的最大下标比count要少1，有时你需要引用count来计算得出下标是多少。比如你可以这样来得到数组的后两位，</p>
<p>16<br>Swift不允许你使用负数作为这种计算的捷径，而另一方面，如果你想要得出倒数几位元素，不妨使用suffix方法：</p>
<p>17<br>对于suffix和prefix方法，都允许范围超出：</p>
<p>18<br>通过前缀的个数多少来取出元素，还可以用前缀的序数来表示取出元素：</p>
<p>19<br>数组的starIndex属性是0，endIndex属性则是count的值。此外，indices属性是以starIndex和endIndex为端点的半开区间。也就是可以取出全部元素的范围。如果你的数组的引用是可变的，你可以改变startIndex和endIndex来获得新的区间。</p>
<p>20<br>indexOf方法会返回某个元素第一次出现的下标，要注意此值是可选值。如果该数组的元素是可比较相等的，那么就可以用==来识别是不是要找的元素。</p>
<p>21<br>即使数组不是可比较相等的元素，你也是可以用自己的函数（用元素为参数，返回bool值）来比较。</p>
<p>22<br>作为序列，数组还有contains方法来验证它是否包含某个元素，同样如果元素是可等的，你也可以用==运算符，或者你可以提供自己的函数（参数为元素类型，返回值为Bool）。</p>
<p>23<br>starWith方法则可以用来检验一个数组的开始元素是不是与给定的序列符合，或者你也可以用==运算符，或者你可以提供自己的函数（参数为元素类型，返回值为Bool）：</p>
<p>24<br>elementsEqual方法则从序列的一般原则比较数组是否相同：两个序列必须等长，而且每个元素相等。你也可以用==运算符，或者你可以提供自己的函数（参数为元素类型，返回值为Bool）。</p>
<p>25<br>minElement和maxElement返回最小或者最大的元素，同样会被包在可选值中以防为空数组。如果元素可比，你也可以用\&lt;运算符，或者你可以提供自己的函数（参数为元素类型，返回值为Bool）。第三行是验证是否绝对值较小的数是两个中的前者。</p>
<p>26<br>如果数组的引用是可变的，append和appendContentsOf这两个实例方法都可以在数组末尾添加新元素。两者的差别是，append参数只是元素类型的单个值，而appendContentsOf则需要一个序列作为参数。比如：</p>
<p>27<br>+运算符被重载为类似于appendContentsOf（不是append）。当+前的运算元是数组时，它不会产生新的数组，所以即使引用的数组是常量也可以用。如果引用是变量，就可以用+=来代替：</p>
<p>28<br>如果数组的引用量是可变的，实例方法insert(atIndex:)将单个元素插入到所给的下标处。如果要一次插入多个元素，可以使用insertContentsOf(at:)方法。<br>如果数组的引用量是可变的，实例方法removeAtIndex可以将该下标的元素移除，实例方法removeLast则会移除最后一个元素，removeFirst则会移除第一个元素。这些方法也会将移除的元素返回，如果你不需要返回值，就不用理他们了。这些值不会被包在可选值里面，并且如果越界会引起崩溃。removeLast还可以引入Int参数，来移除多个值，但是不会返回值，而且如果越界会引起崩溃。  </p>
<p>另一方面，popFirst和poplast将会返回可选值，所以即使是空数组也是安全的。如果引用量是不可变的，你可以用dropFirst和dropLast来返回改变了的数组（确切的说是ArraySlice）。<br>实例方法joinWithSeparator以嵌套数组开头，它会取出单独的数组元素，然后将参数数组插入到原数组元素之间。最后的结果就是被分割的数组，即JoinSeparater，最后在强制转换成数组：  </p>
<p>29<br>调用JoinWithSeparater，以空数组为参数可以“夷平”数组：</p>
<p>30<br>还有专门的实例方法flatten，它会返回JoinSeparater,然后在强制转换为数组。<br>reverse实例方法会产生新的数组，其元素是倒过来的。<br>sortInplace和sort分别能将原始数组整理顺序，和产生新的数组。同样你有两个选择，若果是可比较的就可以用\&lt;运算符，或者提供一个函数接受两个参数并返回一个bool值，</p>
<p>31<br>在最后一行，我提供了一个匿名函数，或者你可以传递一个已经声明了的函数。在Swift中，比较运算符就是它的函数名，因此我可以更简洁地这样做：</p>
<p>32<br>split实例方法将数字分成嵌套数组，并可以传递测试，通过测试的将会被删除。</p>
<p>33<br>数组枚举和变形：<br>数组是序列，所以你可以将它枚举化，通过按顺序检查和操作每个元素。最简单的就是for in循环。</p>
<p>34<br>或者还可以使用forEach实例方法，它的参数是一个函数，该函数的参数是数组的一个元素，没有返回值。它其实就是与for in功能类似的函数。</p>
<p>35<br>如果你还需要元素的下标，调用enumerate实例方法并在结果处循环，这样每次循环得到的都是一个元组。</p>
<p>36</p>
<p>Swift还提供了，三个有效的数组变形实例方法。比如forEach，这些方法都会为你枚举化数组，所以循环是隐含在方法调用中的，这会使你的代码更加简洁。<br>我们先从map实例方法开始，它会产生新数组，其中的新元素都是原数组的元素经过我们所提供函数处理的结果。该函数的参数是数组元素的类型，然后返回的值是有可能为其他类型的值。Swift会自动推断返回的数组元素的类型。<br>比如：可以为数组的每个元素都乘以2</p>
<p>37<br>下面这个例子是说map可以产生不同类型的数组：</p>
<p>38<br>实际开发中的例子：想要将UITableView中的一个section的cell放到同一个NSObject数组中去，sec是section的序号：</p>
<p>39<br>或者可以用更简洁的map方法：</p>
<p>40<br>由于map实际上是CollectionType的实例方法，而区间（本身就是CollectionType），所以可以进一步简写：</p>
<p>41<br>filter实例方法也会产生一个新数组，然而其中的元素是经过过滤的原数组元素，你可以提供具体的过滤函数，该函数接受一个元素类型值并返回一个bool值来验证是否要把该元素过滤掉。</p>
<p>42<br>最后就是reduce实例方法，如果你接触过LISP或者Scheme，你可能对其很熟悉，否则你可能会觉得有点晦涩。这是一种将序列中所有元素都结合在一起的方法，它会产生唯一的值，该值不一定要与原数组元素的类型一样。你需要提供的函数的值有两个参数，第一个参数是结果类型的值，第二个参数是原数组元素的类型的值。每次迭代的结果会自动成为下一次的第一个参数，第二个参数则为下一个数组元素。不过你需要提供第一次迭代时的第一个参数。最后结果就是该值和原数组元素的积累，并且其类型为该值的类型。<br>每一个参数对都会被加总在一起，然后作为下一次迭代的第一个参数，如果我们要的是全部数组元素的加总，那么显然这个值应该是0。</p>
<p>43<br>再一次，我们可以精简这段代码，因为+就是需要函数的名字：</p>
<p>44<br>在实际编程中，我相当以来这几个方法，经常用两个以上，将他们嵌套或者链起来。这里有个例子，虽然看起来有点复杂，但是却很好地解释了如何使用Swift数组。</p>
<p>45<br>Swift Array&amp;Oc NSArray:<br>当你在进行iOS编程的时候，你会将Foundation框架import（或者可以导入UIKit，此框架是已经导入Foundation的），这样Oc的NSArray也会被导入。Swift的Array桥接了Oc的NSArray，但是这种桥接只有在数组类型是可以桥接的时才可以。Oc中能成为数组元素的条件比于Swift既是宽松的又是严格的。NSArray的元素不一定都是一样的类型，另一方面Oc的数组元素必须是对象，这和Oc如何理解对象有关。一般地，如果它可以被向下转型AnyObject，它就可以进行桥接。这就是说要不它是类，要不它是特殊的可以进行桥接的结构体，如Int、Double或String。<br>由此将Array传递给Oc是容易的。若你的Array的元素均可转型AnyObject，那么你可以直接进行传递。通过分配或者作为函数的参数。</p>
<p>46<br>若要在Swift的Array中调用NSArray的方法，你可以把它转型为NSArray：</p>
<p>47<br>Swift的Array只要引用类型为var声明就是可改变的，而NSArray无论是声明什么都是不可以改变的。NSMutableArray才是正解，它是NSArray的子类。你无法转型，分配，传递一个Swift Array到NSMutableArray。你需要先强制变换类型。最好方法就是直接调用NSMutableArray 构造器 init(array:)，你可以直接将Array作为参数传入。</p>
<p>48<br>将NSMutableArray变为Array，则可以用转型（Cast），如果你想要一个原始Swift类型的数组，你需要进行两次转型：</p>
<p>49<br>如果一个Swift对象类型无法转型为AnyObject，那么他就无法桥接至Oc，如果你试着将一个包含该类型实例的数组传递到需要NSArray的地方，编译器就会阻止你。在这种情况，你需要自己进行桥接。<br>比如有一个类型是CGPoint的Array，虽然在Swift中没有任何问题，但是CGPoint是一个结构体，在Oc中就无法使用，你也就不能将它放在NSArray中，如果你试着将它传递到需要NSArray的地方，就会有“<a href="">CGPoint</a>is not convertible to NSArray.”的错误报告。对策是：将每个CGPoint包进一个NSValue中（Oc的对象类型，专门是非对象类型的容器），这样我们就可以有一个类型是NSValue的数组，并可以提交给OC。</p>
<p>50<br>另一种情况就是，可选的Swift数组，Oc的集合类型是不能包含nil的，毕竟在Oc中nil就不是一个对象。所以你就不能把这种包含可选值的数组直接传给需要NSArray的地方。在传递之前，你需要做点事：如果可选值包含值，你可以先进行解包，但是如果它不包含值，就没法解包（nil）。对此，你可以用Oc的NSNull类，它的唯一实例就是NSNull( )，可以代表nil。因此对于一个可选值包着字符串的数组就可以在不是nil的元素上进行解包，在是nil的地方进行NSNull（）代替。</p>
<p>51</p>
<p>现在再来谈谈Oc的NSArray到了Swift的情形，这样方向的桥接是没有任何问题的：NSArray可以很安全地变为Array。但是这样转变来的数组的类型是什么呢？要知道NSArray并没有带着其元素的类型信息。因此默认地NSArray将会变成类型是AnyObject的数组。<br>不过幸运的是，从Xcode7开始，Oc改变了其NSArray, NSDictionary, or NSSet这三种可桥接至Swift的集合类型，使其变得能携带元素类型信息了（OC叫这个是lightweight generic）。而在iOS9中，Cocoa API也修改为可以包含该信息。因此，绝大多数你从Cocoa接受的数组可以直接被识别类型。<br>比如，这种简洁的代码在以前是无法实现的：</p>
<p>52<br>其结果是一个包含字符串数组的数组，分类列出了所有可用的字体。这在以前是不可能的，因为UIFont的这两种方法之前都是不可见的（他们以前会被认为是AnyObject数组），而现在会被认为是返回字符串数组的函数。<br>不过还是很有可能遇到从Oc接受AnyObject数组的情况的，如果真的遇到了，你就需要将其转型或者变为某种特定的Swift类型。<br>下面就是一个Oc类包含一个返回NSArray的方法（没有被类型标记）：</p>
<p>53<br>调用该方法并转换结果，就需要将结果转型为String的数组，</p>
<p>54<br>Oc的数组可以包含多种类型的对象，不要强制将这种数组变为其中元素不能转换的类型，否则就会崩溃。对于这种情况要对症下药！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合类型：&lt;br&gt;Swift，和其他现代编程语言一样，有内置的集合类型数组（Array）和字典（Dictionary），还增加了第三种类型集合（Set）。数组和字典非常重要以至于Swift提供了很多特殊的语法。同时像其他的大部分Swift类型，它也提供了一些相关的的函数；N
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 伞型</title>
    <link href="http://yoursite.com/2017/06/09/iosumbrella/"/>
    <id>http://yoursite.com/2017/06/09/iosumbrella/</id>
    <published>2017-06-09T03:14:07.000Z</published>
    <updated>2017-06-09T03:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>伞型（Umbrella Type）：<br>Swift提供了不少内置类型来作为替班伞型，它们能够在一个标头下包含多个实际类型。<br>AnyObject：<br>在实际编程汇总最常见的伞型就是AnyObject。它其实就是一个协议；它里面是全空的，没有要求任何的属性和方法。它有一个特性：所有的类都会自动采用它。因此在需要AnyObject的地方，任何类的实例都是可以被传递或者赋值的，还可以进行转型（cast）。</p>
<p>1<br>有的不是类的Swift类型，比如String和其他基本数字类型，可以桥接到是类的Oc类型上（被Foundation框架定义）。这就意味着，如果有Foundation框架，这些可以桥接的Swift类型就可以被分配、传递和转型给AnyObject，即使它不是类。因为在后台它会先被自动转换成Oc的类。而且AnyObejct可以被向下转型为Swift的桥接类型，比如：</p>
<p>2<br>遇到AnyObject的常见方法就是与Oc相互转换的过程。Swift向上向下转换AnyObject的方法和Oc向上向下转换id是一样的。实际上，AnyObject就是Swift版的id。<br>NSUserDefaults, NSCoding, and key–value coding都允许你通过String类型的关键名不确定的类中取出对象，这样的对象到了Swift中就是AnyObject，更准确的说是可选值包着的AnyObject，因为很有可能没有这个key，而这种情况Cocoa会返回nil值。一般地，AnyObject对你没什么用；你想的是要Swift知道具体是什么值，解包和转型是由你来决定的。如果你很确定，那么可以用强制解包和强制转型as！  </p>
<p>3<br>抑制类型检查：<br>AnyObject还可以推迟编译器对特定消息可不可发送给对象的检查机制，类似于Oc的输入id可以推迟编译器检查什么消息可以被发送给id。因此你可以在没有将AnyObject转为特定类型的情况下，发送消息给它。（不过如果你知道对象的真实类型，还是尽早转型吧）<br>你不能仅仅发送老旧的消息给AnyObject；这些消息必须相符于满足下面标准之一的类型成员：<br>1、它是Oc的一个类的成员。<br>2、它是你创建的 Oc类的子类（或者扩展）的成员。<br>3、它是Swift类，而且被标记为@objc(或者dynamic)<br>这个特性基本上与可选的协议成员是类似的，虽然有一点小小的差别，让我们从两个类开始：</p>
<p>4<br>Dog的noise属性和bark方法被标记为@objc，所以它们作为潜在消息是对发送给AnyObject可见的。为了验证这个，我将Cat定义为AnyObject再向它发送该消息，先从noise开始：</p>
<p>5<br>这段代码竟然编译了！此外还可以运行！noise属性是被当做可选值包着的其原始类型输入的。而在这里它是可选值中包着String (Dog实现)。如果被声明为AnyObject的没有实现noise，那么它就会无害的返回nil。此外不像可选协议属性，该可选值会被隐式解包。因此如果AnyObject是实现了noise属性的类型（比如Dog），结果就是String。<br>现在再试试调用方法。</p>
<p>6</p>
<p>如上，如果该类型没有实现noise，那么将会返回nil，如果实现了结果就是可选值包着的String。使用bark!( )，结果是String，但是如果没有实现，那么程序就会崩溃。不像可选协议成员，你可以直接发送不解包的消息，这样和！强制解包效果是一样的：</p>
<p>7<br>对象身份和类型身份：<br>有时，我们想知道的不是一个对象的类型是什么，而是这个对象是不是我们想的那个特定的对象。这个问题不会出现在值类型上，而会出现在引用类型上。可能类是引用类型，所以这个问题会出现在类的实例上。<br>Swift使用===运算符来解决这个问题。===可以被采用了AnyObject协议的对象类型实例使用，比如类。它不是像==那样比较值是不是相等，它是检验两个对象是不是引用同一个对象。它的否定形式是！==<br>一个典型的使用场景就是Cocoa中的类的实例，你想知道它是不是你所引用的对象。比如：NSNotification有一个object属性来帮助识别notification（usually, it is the original sender of the notification）。Cocoa不知道它的下级类型，这是另一个你将得到可选值包着Anyobject的情况。就像==，===也可以自动解包的，所以你就可以用它来确定object就是你想要的对象了。</p>
<p>8<br>AnyClass：<br>AnyClass是AnyObject的类型。它相当于Oc中的Class类型，当Cocoa API想要说需要一个class，就会出现在其声明中了。<br>比如，UIView的layerClass类方法用Swift的方法声明时：</p>
<p>9<br>这意味着：如果你重写该方法，会返回一个类。这大概是CALayer的子类。为了在实现中返回一个确切的类，把self消息发送给该类：</p>
<p>10</p>
<p>AnyClass对象的引用和AnyObject对象的引用很相似。你可以发送任何Swift知道的Oc消息，比如任何的Oc的类消息。</p>
<p>11<br>Oc可以看到whatDogSays，并把它看做类类属性。因此你可以发送whatDogSays给AnyClass的引用。</p>
<p>12<br>类型的引用变量（你可以通过发送dynamicType消息给其实例来获得其类型，或者通过其类型名后面加self来获得）的类型采用了AnyClass，你可以使用===来比较不同引用：</p>
<p>13<br>如果d和whattype是一样的类型，这个就是true（这里不支持多态）。比如。Dog有个NoisyDog子类，如果参数分别是Dog( ) Dog.self ,或者 NoisyDog( ) NoisyDog.self，就是true。但是如果是 NoisyDog( ) Dog.self 就是正确的。<br>即使没有多态，这也是很有价值的。因为当在后面的是类本身的引用时，你不能用is运算符。<br>Any：<br>Any是一个被所有类型采用的空协议的别名。因此，可以用Any的地方，所以类型都能用。</p>
<p>14<br>一个Any类型的对象可以被检验、转型到任何对象和函数类型。为了说明，这里有一个有关联类型的协议，还有两个显式决定其类型的采用者。</p>
<p>15<br>现在这个函数需要两个参数：一个是Flier 一个是Any。检验第二个参数类型是不是和第一个参数的Other一样，这是合法的，因为Any可以和任何的类型的检验。</p>
<p>16<br>如果我调用Bird和Insect为两个参数，那么就会显示they can flocktogether。如果我调用其中之一和另一种不是这两个的类型，就不会输出了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伞型（Umbrella Type）：&lt;br&gt;Swift提供了不少内置类型来作为替班伞型，它们能够在一个标头下包含多个实际类型。&lt;br&gt;AnyObject：&lt;br&gt;在实际编程汇总最常见的伞型就是AnyObject。它其实就是一个协议；它里面是全空的，没有要求任何的属性和方法。
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 扩展</title>
    <link href="http://yoursite.com/2017/06/09/iosextension/"/>
    <id>http://yoursite.com/2017/06/09/iosextension/</id>
    <published>2017-06-09T03:12:58.000Z</published>
    <updated>2017-06-09T03:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>扩展：<br>扩展是将你自己的代码插入到已经存在的对象类型中的方法，即extending an existing object type。这种扩展可以在自己定义的类型中，也可以是Swift本身的对象类型，还可以是Cocoa的对象类型。总之，扩展可以将你的代码打入你的甚至别人的类型中！<br>扩展的声明必须是在文件的最顶端。声明扩展：关键字extension放在已经存在的对象类型名之前，之后如果要加协议，那么就添加冒号和要添加的协议，之后再加大括号，里面写内容。此处的限制如下：<br>1、扩展不能重写已经存在的成员。（但是它可以重载已经存在的方法）<br>2、扩展不能声明存储属性。（但是它可以声明计算属性）<br>3、类的扩展不能声明指定构造器和析构器。（但是它可以声明便利构造器）<br>扩展对象类型：<br>在真实的编程过程中，为了封装一些不存在的函数（通过将它表达为属性或者方法），我有时会扩展Swift内部类型或者Cocoa类型。这是一些真实app的例子：<br>在某个纸牌游戏中，我需要进行洗牌，而牌储存在数组里面。那么我就扩展了Swift的Array，给它一个shuffle方法：</p>
<p>1<br>再如Cocoa的Core Graphics 框架有很多很有用的函数与CGRect结构体有关，Swift对它有诸多扩展，不过对于取得CGRect的中心坐标（Center Point : CGPoint），还没有捷径可走。所以我就扩展出了center属性：</p>
<p>2<br>扩展可以定义static和class方法。由于对象类型常常是全局可用的，所以这不失为是构造一个全局函数的好办法。比如，如果觉得金色会在开发中常常使用到，就没有必要每一次都重复定义，可以将它封装在全局函数中。然而也不需要直接构造一个全局函数，我们可以将他封装在UIColor中：</p>
<p>3<br>现在你就可以像调用UIColor.redcolor一样，使用UIColor.myGoldenColor来调用颜色了。<br>另一个扩展很好用的地方就是使Cocoa内置类和你自己的数据类型一起工作。比如在Zotz App中，我定义了一个枚举类型，用来读档存档。</p>
<p>4<br>其中的问题就是，让我存档时我需要每次调用rawValue。</p>
<p>5<br>这看起来很丑，所以必须要改。我们可以教会NSCoder（coder的类）怎样去干活儿。在这个扩展中，我重载了encoderObject:forKey” 方法：</p>
<p>6<br>事实上，我将rawValue的调用从我自己的代码中放进了NSCoder里。现在我就可以这样调用了：</p>
<p>7<br>扩展还可以整理对象类型的代码。一个常见的应用就是为对象类型增加其采用的协议。比如这样：</p>
<p>8<br>如果你觉得多行定义你的对象类型太复杂，那么用扩展可以很好地分解代码。<br>当你对Swift的结构体（Struct）进行扩展的时候，一个有趣的事情发生了：你声明一个构造器，原先的隐式构造器（Implicit initializer）可以保留下来：</p>
<p>9<br>这段代码意味着你可以通过显式构造器Digit（），也可以用原先的隐式构造器Digit（number：）。这样即使我们显式定义了构造器，也不会使原先的隐式构造器消失。<br>扩展协议（Extending Protocols）：<br>在Swift2.0中，你可以扩展协议了！<br>像扩展其他的对象类型一样，你也可以扩展协议的方法和属性。不像协议的声明中方法和属性仅仅是要求采用者实现，扩展协议会是采用者继承该方法和协议，也就是说它们是真正的方法和属性。</p>
<p>10<br>看上面，Bird可以不用实现fly（）就继承Flier。这是因为Flier协议的扩展提供了该方法，Bird实际上继承了fly（）：</p>
<p>11<br>采用者可以实现从扩展协议继承来的方法，再重写它：</p>
<p>12<br>但是请注意：这种继承不是多态的。采用者的实现不是重写；而仅仅是另一个实现。内部识别规则不适用，关键是引用。</p>
<p>13<br>即使f在内部其实是Insect(用is运算符可以知道)，fly消息还是会发送给Flier。<br>为了将它变得看起来像多态继承，我们必须将fly在原协议中定义：</p>
<p>14<br>现在Insect就保持了它的内部完整：</p>
<p>15<br>这种差异是有意义的。因为协议采用不会引入动态分配。因此编译器必须进行静态决定。如果在原协议中，要求方法被声明，那么采用者就必须实现它，所以我们就可以调用该方法。但是如果该方法仅仅存在于协议扩展，这就取决于运行的动态分配（Dynamic Dispatch）。这就有可能使得协议落空，所以消息就被发送到协议扩展去了。<br>协议扩展的主要好处就是允许代码被转移至一个合适的Scope中。这里有一个例子：我有四个枚举类型，每一个都代表了Card的一个属性，Fill、Color、Shape和Number。他们都有一个人int类型的初始值。我对与每次都赋给rawValue有点烦躁了，所以就给每个枚举类型一个没有外部参数名的代理构造器，它们会调用内置的init(rawValue:)构造器：</p>
<p>16<br>尽管我不喜欢这样的方式，但是在Swift1.2之前我没有任何办法。而现在，我可以用协议扩展来改变这种情况。带有初始值的枚举类型将会自动采用内置的协议 Rawpresentable，初始值的类型别名叫做RawValue。所以我可以将我的构造器加入到此协议中：</p>
<p>17<br>在Swift标准库中，协议扩展意味着很多全局函数可以被改写为方法。比如，在Swift1.2之前，enumerate是一个全局函数：</p>
<p>18<br>原先这个函数只能是全局函数。<br>这个函数只作用于序列（sequence），所以也是SequenceType协议的采用者。在Swift2.0之前，怎样实现呢？enumerate可能在SequenceType协议中被定义（requirement），但是这意味着所有的采用者都要实现它，这显然不可能。所以我们只能把它声明为一个全局函数，然后用泛型约束保证入口，用序列作为参数。<br>在Swift2.0，enumerate就可以当做方法定义在SequenceType协议中了：</p>
<p>19<br>现在就不需要什么泛型约束了，也不需要泛型，甚至不需要参数。被发送了enumerate消息的序列就是要飙车enumerate的序列。<br>这个例子的方法可以被广泛使用。很多Swift标准库的全局函数变成了方法。<br>扩展泛型：<br>当你扩展泛型类型的时候，占位符类型名对于你的扩展声明是可见的。你很可能用到它们。不过这会使你的代码变得不清楚，因为看起来你在使用没有被定义过的变量。所以最好加点注释。</p>
<p>20<br>在Swift2.0中，泛型类型扩展可以包含where语句了。这和泛型约束的效果类似：它限制了决定泛型类型的代码，向编译器保证你的代码是合法的。<br>通过协议扩展，这意味着全局函数可以用作方法。看下面的这个例子：</p>
<p>21<br>为什么我要用全局函数呢？因为在Swift2.0之前我不得不这么做。如果我想把它（求最小值）变成Array的一个方法，在Swift1.2之前，我可以扩展Array而且也可以引用Array的泛型占位符，然而它不能进一步限制占位符。所以这里没有办法将此方法插入Array并保证该占位符代表的类型是 Comparable，所以编译器也不允许使用\&lt;比较Array的元素。而在Swift2.0就大大不同了。不仅可以更进一步地约束泛型类型，而且还可以将它变成Array的方法。</p>
<p>22<br>这个方法只能被元素是Comparable的序列调用，否则编译器将拒绝它们。<br>第二行不编译的原因就是因为我没有使Digit结构体采用Comparable。<br>同样这个改变也使得Swift的标准库有大规模的改变，允许把全局函数写入结构体扩展或者协议扩展作为方法。比如，全局函数find（在Swift1.2之前）变成了集合类型的indexOf方法，此方法的元素必须是Equatable。</p>
<p>23<br>这就是协议扩展，同样也是运用where语句的泛型扩展，二者在Swift2.0之前都是不被允许的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;扩展：&lt;br&gt;扩展是将你自己的代码插入到已经存在的对象类型中的方法，即extending an existing object type。这种扩展可以在自己定义的类型中，也可以是Swift本身的对象类型，还可以是Cocoa的对象类型。总之，扩展可以将你的代码打入你的甚至别人
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 泛型</title>
    <link href="http://yoursite.com/2017/06/09/iosgeneric/"/>
    <id>http://yoursite.com/2017/06/09/iosgeneric/</id>
    <published>2017-06-09T03:12:08.000Z</published>
    <updated>2017-06-09T03:12:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>泛型：<br>泛型是一种类型的占位符，具体的类型将会在之后被填充。由于Swift的严格类型检验，这是很有用的。在不能或者不想提前设置类型的情况下，程序可以不被严格类型检验所限制。<br>当然理解泛型实质上并非削弱了Swift的严格类型检查机制是非常重要的。特别地，它没有把解决类型推迟到运行的时候。当你使用泛型的时候，你的代码还是会说明清楚它的实际类型；在运行的时候，泛型代表的类型其实也是清清楚楚的。你的代码中需要写类型的地方可以用泛型来替代，这是就不需要完全表达清楚，但是这个代码被其他代码使用的时候，这个类型就需要被明确了。虽然占位符是泛型，但是实际上处理的时候是按照正常的类型来的。<br>可选值是一个很好的例子。任何类型都可以包装为一个可选值。同样你也不知道一个可选值中包装的是哪一种类型。这是怎么做到的？其中的原因就是可选值是一个泛型类型。下面我说说是怎么工作的。<br>我之前有提到可选值是一个枚举类型，有两个case：.None ; .Some。如果一个可选值的case是.Some，那就有关联值——被可选值包装的类型。但是该关联值究竟是什么类型的呢？在一方面，它可以是任何类型，这也正是为什么可选值是可以任何类型的原因。再一方面，可选值是包含特殊类型的。当你进行解包的时候，他要被赋给它本身的类型，所以才能向它发送指令。<br>在Swift头文件中可选值的枚举声明像这样开始：</p>
<p>1<br>这个句法的意思就是：在声明过程中，我用捏造出的类型——占位符，我把它叫做wrapped。它是确切的而且是独立的。当然现在还不知道他究竟是什么类型、你只需要知道我说wrapped是代表，一个将会确定的类型。一旦该可选值被建立，那么wrapped所代表的类型就确定了。<br>可选值声明更详细的如下所示：</p>
<p>2<br>声明wrapped是一个占位符后，我们将会继续使用它。.Some 这个case有一个关联值，类型是wrapped。我们还有一个接纳wrapped类型参数的构造器。因此，无论将来的具体类型是什么，构造器参数和关联值都会是同样的类型。<br>正是构造器参数和关联值类型的一致才允许后者被实现。。在可选值枚举的声明过程中，wrapped是一个占位符。但是在现实中，当一个实际可选值被实现，将会有具体的类型给出。我们常常用问号语法糖（String?）并且构造器将在幕后被调用。现在为了表意清楚起见，使用显式构造器：</p>
<p>3<br>在这个可选实例中，wrapped的类型就被决定了。显然，howdy是一个字符串。编译器就接到了指令，在后台，将所有的wrapped都替换为了String。因此s其实在编译器的“脑海”中是这样的：</p>
<p>4<br>这就是wrapped被替代之后的伪代码。我们可以将它总结为Optional\<string\>。事实上，这是合法的语法。我们可以这样写上面的代码：</string\></p>
<p>5<br>大量的内置Swift类型包含泛型。<br>泛型声明（Generic Declarations）：</p>
<p>下面是“哪里可以用泛型”的列表：<br>泛型协议 + Self：<br>在协议中，用关键字Self可以将这个协议边做泛型。<br>Self 是作为一个占位符，代表着采用者的类型。比如，这里有一个例子，在声明方法是引用了一个Self参数：</p>
<p>6<br>这意味着如果Bird对象类采用了该协议，那么f的类型就是Bird了。<br>泛型协议 + 控类型别名：<br>协议可以在不确定别名具体代表哪种类型的条件下，声明一个类型别名，即typealias语句不包含等于号。这也会把协议变成泛型协议；这个别名，叫做关联类型（associated type），是一个占位符。比如：</p>
<p>7<br>采用者会具体声明占位符的类型。如果Bird结构体采用了Flier协议，并且flockTogetherWith参数f是Bird类型，那么也就决定了第二个mateWith的参数也应该是Bird类型。即：</p>
<p>8<br>上面的代码和f:Self.other 效果是一样的。<br>泛型函数：<br>函数声明可以在几乎任何地方使用泛型（参数、返回值和函数内部）。将占位符名字置于\&lt;>中，并跟在函数名之后：</p>
<p>9<br>调用者会使用特定的类型来代替占位符：</p>
<p>10<br>因此，此地的T就是String。<br>泛型对象类型：<br>在对象类型声明的尖括号中，可以随便用泛型占位符。在对象名之后用尖括号圈起占位符名字：</p>
<p>11<br>该对象类型的使用者可随意确定类型。</p>
<p>12<br>此处T就是String。<br>对于泛型函数和泛型对象类型（使用尖括号），可以包含多个占位符名，并用逗号隔开。比如：</p>
<p>13<br>这两个占位符可以代表不同的类型，虽然他们不一定非要这么做。<br>类型约束（Type Constraint）：<br>上面我们谈到的都是允许任何类型去替代占位符的方法。或者，你也可以通过限制，来使只有有资格的类型去决定占位符是什么类型。这就叫做类型约束。最简单的类型约束形式就是：在占位符第一次出现时，在其后面加分号和类型名。类型名可以是类名和协议名。<br>回到我们的Flier和flockTogetherWith函数。假定我们想要说，flockTogetherWith的参数应该是采用了Flier协议的类型。那么我们就不能通过在协议中声明该参数的类型为Flier来实现。</p>
<p>14<br>这个代码就是说：采用该协议的采用者的函数的参数f必须为Flier类型，这显然和我们想的不太一样：</p>
<p>15<br>我们想要的是Bird采用该协议，而且f必须是Flier的采用者，比如说是Bird。可能可以这样实现：</p>
<p>16<br>不过这样是不合法的：一个协议不能将自己作为类型约束。一个变通方法就是在定义一个额外的协议，让Flier自己采用，然后再把Other约束到该方法上。</p>
<p>17<br>这个合法的采用者可以是：</p>
<p>18<br>在泛型函数或者泛型对象类型中，这个类型约束需要放到尖括号里面。比如：</p>
<p>19<br>现在你不能给该函数参数为String，因为String不是一个Flier。此外，如果Brid和Insect都是Flier采用者，那么两个Bird可以用作此处参数，两个Insect也可以，当然一个Bird一个Insect不小，因为这里只有一个T。<br>占位符的类型约束常常是保证编译器能向占位符类型实例传特定消息的有效方法。比如myMin方法（返回特定类型中的最小值）：</p>
<p>20<br>但是它不会编译。原因在于thing<a href="">ix</a> \&lt; minimum这一行，编译器不知道它们的类型即T，能不能被用了比较。解决办法就是给T一个协议，Comparable protocol。</p>
<p>21<br>现在它就可以编译了。正是因为向编译器保证了可以引入的参数都是可比较的。可以比较的内置类型（Int String Double Character）都采用了该协议。如果你看了Swift头文件，你就会发现min函数其实就是这样定义的，也是为了这个原因。<br>一个泛型协议（用Self 或者 关联类型的）可以在泛型中被用作一个类型，作为类型约束。下面的不会编译：</p>
<p>22<br>为了将这个Flier泛型协议用作类型，我们必须写一个泛型而且用Flier为类型约束：</p>
<p>23<br>显式具体化：<br>之前的例子都是通过类型推断来决定占位符的实际类型的。然而还有一种方式去进行决定：手动决定类型。在某些情况下，这种显式具体化是强制要求的，比如占位符类型无法通过推断来决定的时候。<br>这里有两种显式具体化的形式：<br>泛型协议 + 关联类型：<br>通过使用协议别名的显式类型分配的typealias的声明，协议的采用者可以手动决定协议的关联类型。比如：</p>
<p>24<br>泛型对象类型：<br>通过首先在声明中写包含在尖括号中的真正类型，泛型对象类型的使用者可以手动决定对象的占位符类型。比如：</p>
<p>25<br>（这就解释了为什么有用Optional\<string\>）<br>你不能直接显式具体化一个泛型函数。但是你可以声明一个用泛型占位符的泛型类型（带有非泛型函数），这个泛型类型的显式具体化可以决定这个占位符，继而决定这个函数。</string\></p>
<p>26<br>当一个类是泛型，你在subclass它时可以自己决定他的泛型的类型（new in Swift 2.0），有两张方式：</p>
<p>27<br>1、你可以将子类做成和父类一样的泛型占位符类型:</p>
<p>28<br>2、也可以将它进行显式具体化：</p>
<p>29<br>关联类型链：<br>当一个泛型占位符通过关联类型采用泛型协议时，该关联类型可以通过点号链接到占位符名字而确定其类型。<br>这里有个例子。想象在一个游戏程序中，soldiers和archers是彼此的敌人。我要通过建立同时采用Fighter协议（有Enemy关联类型，Enemy采用Fighter的）的Soldier结构体和Archer结构体来描述这种情况。（同样，我要用额外的、Fighter采用的一个协议）</p>
<p>30<br>我将手动决定这两个结构体的关联类型：</p>
<p>31<br>然后我创建一个泛型结构体去表示阵营。</p>
<p>32<br>现假定，某个阵营可能包含敌对阵营的一个间谍。即Soldier阵营的spy是Archer，Archer阵营的spy是Soldier。更一般地，由于T是Fighter，所以spy也是Fighter。通过关联类型链接至占位符名可以清楚地表述：</p>
<p>33</p>
<p>34</p>
<p>35<br>更长的关联类型名链也是允许的。特别是，当一个泛型协议有一个关联值（本身就采用了带着关联值的泛型协议）。<br>比如，我们给两个阵营角色武器：a soldier has a sword, while an archer has a bow.分别建立Sword和Bow结构体，再让它们采用Wieldable协议：</p>
<p>36<br>我将把Weapon（采用了Wieldable）关联类型赋给Fighter，然后再一次为它们决定类型。</p>
<p>37<br>现在再假设每个Fighter都有偷敌人武器的能力：为Fighter泛型协议加一个steal(weapon: from:)方法。如何正确定义该方法，才能使采用者正确定义参数的类型？<br>from:的参数类型是Fighter的Enemy，即Self.Enemy。而对于weapon的参数类型就是该Enemy的武器了，所以就是Self.Enemy.Weapon:</p>
<p>38<br>这段代码将会编译，如果我们省略Self，也是可以的。<br>由于改变了协议，原先的代码也要改变成如下：</p>
<p>39<br>Swift头文件中关联类型链有着大量应用,Generator.Element相当常见，因为它表示了一系列的element的类型。这个系列类型的泛型协议有一个关联类型产生器，它采用了产生器类型的泛型协议，这又将以此有一个关联类型element。<br>额外约束：<br>一个简单的类型约束会将一个占位符限制为一个单一的类型。有时候你往往想要多一点限制，即额外约束（addtional constraints）。<br>在一个泛型协议中，类型别名限制的分号其实和类型定义处的分号是一样的。所以它之后可以加多重协议或者父类（单个）。</p>
<p>40<br>在Generic协议中，关联类型T只可以是采用了Flier和Walker协议的类型，U则只可以是Dog类（或其子类）和采用了Flier协议的类型。<br>在泛型函数或者泛型对象类型的尖括号中，这种语法是错误的。你可以这样代替：使用where语句，其中包括一个或者多个额外约束：</p>
<p>41<br>通过关联类型链，where语句也可以用在已经约束了占位符的协议的关联类型上。下面的伪代码展现了我想说的。我省略了where语句的内容，以专注于其用法。</p>
<p>42<br>T已经被约束为Flier。Flier本身就是一个带有关联类型Other的泛型协议，因此T的类型将会决定Other。通过限制Other的类型，where语句更进一步地约束了能够约束T的类型。<br>那么我们怎样实现呢？</p>
<p>43<br>Bird和Insect都采用了Flier，但是他们并非都有资格调用flockTogether。</p>
<p>44<br>类也一样：</p>
<p>45</p>
<p>46<br>除却分号，我们还可以用 == 和类型名。在关联类型链末端的类型必须是确切的类型，而非仅仅是采用者或者子类。比如：</p>
<p>47<br>Insect成立，而Bird不成立。<br>而使用了==，上面的Pig类必须是Dog才行，NoisyDog则不成立。<br>在==后面的类型也可以是关联类型链。此时两端的关联类型链必须一致。</p>
<p>48<br>上面的例子，可以引入两个相同的结构体，但是如果不一样，就不满足其条件了。<br>Swift头文件扩展了 ==和where语句相结合的办法。特别是用来限制系列类型。比如，String的appendContentOf方法被声明两次：</p>
<p>49<br>appendContentOf方法不仅可以将两个String组合在一起，而且还可以将一个String和一个字符序列（Character Sequence）组合：</p>
<p>50<br>字符串数组也可以：</p>
<p>51<br>它们都是字符序列，就像appendContentOf的第二个声明中的，其实就是采用了SequenceType 协议的类型。都是它也不是之前的序列；它的Generator.Element必须是Character。Generator.Element链是Swift表达序列元素类型的方法。<br>数组结构体也有appendContentsOf，但是有一点区别：</p>
<p>52<br>相信大家都知道有什么区别，已经其中的原因。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型：&lt;br&gt;泛型是一种类型的占位符，具体的类型将会在之后被填充。由于Swift的严格类型检验，这是很有用的。在不能或者不想提前设置类型的情况下，程序可以不被严格类型检验所限制。&lt;br&gt;当然理解泛型实质上并非削弱了Swift的严格类型检查机制是非常重要的。特别地，它没有把解
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 协议</title>
    <link href="http://yoursite.com/2017/06/09/iosprotocol/"/>
    <id>http://yoursite.com/2017/06/09/iosprotocol/</id>
    <published>2017-06-09T03:11:28.000Z</published>
    <updated>2017-06-09T03:11:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>协议<br>协议是一种表示类型的相通性的方法，往往这些类型某些方面迥异。比如，一个Bee对象和一个Bird对象就在飞行方面有共同之处。因此定义一个Flier类型就很有用。问题来了：在哪种意义上，Bee和Bird可以算Flier呢？<br>除了继承，当然一个可能的选择是类继承的方式。如果Bee和Bird都是类，对于父类和子类是有继承关系的。所以Flier可以使Bee和Bird的共同父类。然而这不一定是对的。因为Bee是一种昆虫，而Bird不是。虽然他们都可以飞行。所以我们需要一个类，能把他们联结在一起。<br>此外，如果Bee和Bird不是类怎么办？要知道在Swift中，这是很可能发生的，很多重要的对象都可以由结构体来替代类。但是结构体却没有继承等级。别忘了这是结构体和类的最主要的区别。所以说结构体也需要和类一样能够表达共同性。<br>Swift通过协议(Protocol)来解决这个问题。协议相当重要，在Swift Header中超多70个协议。此外Oc也有协议。Swift和Oc的协议大致相符，而且可以互换。Cocoa很依赖协议。<br>虽然协议是一种对象类型，但是却没有一个协议对象——你无法实例化一个协议。协议相当轻量化。一个协议的声明只是一堆属性和方法的列表。属性没有值，方法中没有代码。一个“真正的”对象就可以声明它属于这个协议；或者是说他采用(adopting)或者遵循(conforming)该协议。一个对象类型一旦采用了该协议就是表明它会使用协议列出的属性和方法。<br>比如说，作为一个Flier需要包括一个fly方法。所以Flier协议就可以标明fly方法：在协议的列表中添加fly，并且使函数体为空，就像这样：</p>
<p>1<br>任何类型，包括枚举、结构体、类甚至其他的协议都可以采用这个协议。可以在协议前面用分号在声明中连接到上面类型名后面。（如果采用者是子类，协议跟在它的父类之后，中间用逗号号隔开。）<br>若Bird是一个结构体，它可以这样采用Filer协议：</p>
<p>2<br>出现了点问题，原来是没有遵循协议内容使用fly方法，现在改一下：</p>
<p>3<br>以上就是协议的大致内容，不过在现实中，我们还需要协议中的方法充实一点。<br>Tips：在Swift2.0中，多亏了协议扩展，协议可以声明方法并且提供具体实现内容，之后我将讲解。<br>为什么要用协议？<br>你现在可以对于为什么要用协议摸不着头脑。我们让Bird采用了Flier，之后呢？如果我们想要Bird知道怎么去fly，为什么我们不直接给他一个fly方法，反而给他协议呢？原因和类型分不开。别忘了，协议也是一个类型。Flier也是。所以我可以在任何我能用类型的地方使用Flier—— 将它声明为一个变量，例如用在函数参数处。</p>
<p>4<br>想想上面的代码，它包含了协议的全部点。一个协议是一种类型，所以多态是成立的。协议提供了另一种表达类型和子类型概念的方式。由于可替换原则，这意味着Flier可以是任意类型的一个实例（注意定义的是实例方法，而非类方法）。无论对象类型是哪种，只要它采用了Flier协议，因为只要采用了该协议，就会有一个fly方法。因此编译器就会允许我们向这个对象发送fly消息。这样说了，一个Flier就是可以向其发送fly的对象。<br>然而反过来就不正确，也就是说有fly方法的对象不一定是Flier。毕竟只有采用了该协议才是Flier。</p>
<p>5<br>这个Bee虽然有fly方法，但他不是Flier，所以tellToFly是不会接受它作为其参数的。为了使代码编译，可以在其声明后添加Flier协议：</p>
<p>6.1</p>
<p>6.2</p>
<p>现在可以说下实际应用了。就像我之前说的，Swift中有大量的协议，让我们使用一二吧。其中一个很有用的协议就是CustomStringConvertible。这个协议需要我们使用description字符串属性。这有一个神奇的效果：当该属性的实例被用在字符\插入(Interpolation)或者输出(Print)的时候，description属性值将自动用于代表这个实例。<br>注意一个类型是可以采用多个协议的。比如Double类型就采用了CustomStringConvertible, Hashable, Comparable 等等协议。</p>
<p>7</p>
<p>当然上面的代码是不会编译的，因为我虽然让他们采用了上述的协议，但是在结构体内部没有定义具体的代码。<br>协议类型的检验和转型：<br>协议是一种类型，而且协议的采用者是其子类型。所以多态是适用的。因此当对象被声明为协议类型时，在对象的声明类型和实际类型之间调节的运算符就会工作。比如说，可以用is运算符去检测该对象是Bee还是Bird，因为声明类型Flier既可以是Bee又可以是Bird。</p>
<p>8<br>类似地，as!和as?可以被用来将声明为协议类型的对象转型为实际类型。这个能力相当重要，因为接受协议的对象常常需要传递消息，而这协议是不能完成的。比如getworm这个方法：</p>
<p>9<br>Bird作为Flier，它可以fly，而作为Bird，它可以getWorm。所以你不能告诉所有的Flier都让他们去getWorm：</p>
<p>10<br>所以此时就需要将其进行转型：</p>
<p>11<br>声明一个协议：<br>协议只能在文件的最顶端声明。通过使用关键字protocol来进行声明，之后写协议名（作为类型名，首字母大写），之后再跟大括号，里面写这些东西：<br>属性（Properties）:<br>在协议中，属性声明包括var关键字（不能是let）、属性名、冒号、其类型和大括号（包含get或者get set）。在以前，采用者对于属性的具体实施可以是可写入的，而在现在，它必须是：作为只读的计算属性或者常量（let）存储属性，调用者不能使用get set 属性。<br>至于声明static或者class属性，可以在属性前加static关键字。如果是采用者是类，那么和在类属性里面一样自由。<br>方法（Method）:<br>协议中的方法声明就是将普通函数声明去掉函数体，也就是，它没有大括号和函数内容。任何对象函数类型都是合法的，包括init和subsccript。（下标也是没有大括号和函数内容，但是和属性一样，会有get 或者get set）。<br>至于声明static或者class属性，可以在属性前加static关键字。如果是采用者是类，那么和在类属性里面一样自由。  </p>
<p>当在枚举类型或者结构体类型中使用时，如果一个方法需要被声明为mutating，那么这个协议必须标记为mutating；而且如果协议中没有mutating，协议采用者不能添加mutating。但是，协议中有mutating，采用者可以省略。（其实这里说的都是要有mutating）<br>类型别名（Type Alias）:<br>协议声明中可以引入内部类型别名（Type alias）作为原本类型名的同义词。比如，typealias Time = Double 允许Time类型在协议大括号内部进行引用。其他地方，比如采用者类型中，Time并不存在，但是Double是它的一个匹配。<br>协议采用（Protocol adoption）：<br>协议自身就可以采用别的协议（一个或者多个），方法就像你所想的，分号后面用逗号隔开。事实上，这为你提供了建立完整的类型的二级继承体系！这在Swift头文件中被大量运用。<br>为了表达清楚，采用了别的协议的协议可能需要重复被采用协议的内容（在大括号里的），但是由于这种重复可能是隐式的，所以也不是必要的。然而，对象类型采用了这种协议既要满足此协议中的内容，还要满足该协议采用的其他协议的内容。<br>Tips：如果一个协议的目的仅仅是为了将其他协议组合起来（通过采用别的协议），而没有添加任何的新要求，而且你只在一个地方用这个协议的话，你大可不必这样。你可以直接用protocol\&lt;…,…>，括号里面的协议用逗号分隔。<br>可选的协议成员：<br>在Oc中，协议的成员可以被声明为可选值，表示该成员不一定要在采用者中实现。为了更好地兼容Oc，Swift允许可选的协议成员，但是只限于显式桥接到OC的协议中（通过将@objc置于协议之前），在这种协议中，可选的成员即内部的方法和属性也要标记optional：</p>
<p>12<br>只有类才可以采用这样的协议，而且该特性在该类是NSObject的子类的情况下才会工作，或者可选成员被@objc标记、</p>
<p>13<br>协议采用者并不保证会将可选成员实施，所以Swift不知道对其发送song或者sing消息是否安全。<br>在这种情况下，Swift通过将song包装进可选值中来解决问题。如果Flier 的采用者没用实现该属性，那么其结果就是一个nil，显然这没有什么危害。</p>
<p>14<br>Tips:这是个很少见的情况，会以双重包装的可选值结束。比如，如果可选属性的值是String?，那么取得的值就是String??。<br>Warning：该可选属性可以通过其协议被声明为{get set}，但是没有合法的语法在这种协议类型的对象中去为这种属性赋值。如果f是一个Flier，song被定义为{get set}，你就不能设置f.song，我觉得这是一个Swift的bug。<br>像sing这样的可选方法，可能还要更复杂一些。如果方法没有被实现，我们是被禁止首先调用它的。为了解决这个问题，该方法自己就自动被标记成了该类型的可选值。因此要向它发送消息，就必须先进行解包。比较安全的方法就是用？解包：</p>
<p>15<br>这段代码就可以很安全地运行了。只要采用者实现了sing，那么效果就是向f发送sing。如果Flier采用者没有实现sing，什么事也不会发生。如果用！强制解包，那么后面那种情况程序就会崩溃。<br>如果可选的方法返回一直值，那么此值也会被包在可选值中：</p>
<p>16<br>如果你调用sing？( )，结果返回的就是可选的字符串：</p>
<p>17<br>如果用！，那么结果就是String。<br>很多Cocoa协议都有可选成员。比如你的iOS app有一个app delegate类就采用了UIApplicationDelegate 协议。该协议的方法都是可选的。然而，事实上，这不会对你调用它们有什么影响，（你不需要对他们进行特别标注即@objc），因为你的appdelegate类已经是NSObject的子类了，所以这个特性将会直接生效，而不管你实不实现方法。同样地，你常常会使UIViewController的子类采用有可选成员的Cocoa delegate协议，这也是NSObject的子类，所以你直接实现你想实现的方法就可以了，而不用特别的标记。<br>类的协议：<br>类的协议是指，在声明中协议名后面冒号跟着class关键字的协议，表示它只能够被 类 对象类型 采用：</p>
<p>18<br>（如果协议已经被@objc标记，那么就没有必要标记class了，因为@objc属性已经暗示它是一个类的协议了。）<br>一个主要的使用类的协议的原因就是：利用类的特性——特别的内存管理机制。</p>
<p>19<br>关键字weak标记了delegate属性作为特殊内存管理，只有类的实例才有这种特殊内存管理。delegate属性是协议类型，而结构体和枚举都可能采用协议，所以为了满足编译器的要求：该对象事实上是类的实例，而不是结构体或者枚举的实例，所以这个协议被声明为类的协议。<br>隐式Required构造器：<br>设想一个协议声明了一个构造器，而且一个类采用了这个协议。由于该协议的规定，该类和其子类必须实现该构造器。因此该类不仅要实现构造器，而且它必须标记其为required。所以说，定义在协议中的构造器是隐式required，该类被显式强制实现这个要求。</p>
<p>20<br>编译错误：Initializer requirement init( ) can only be satisfied by a required initializer in non-final class Bird.<br>为了解决这个问题，我们必须指定我们的构造器为required：</p>
<p>21<br>或者，就像刚刚错误提示，还有一种方法，标记Bird类为final。这意味着它就不能有任何子类了——这也保证了这个问题不会再出现了。所以如果Bird标记为final，就不需要标记它的init为required了。<br>上面的代码汇总，Bird并没有被final标记，而是它的init被required标记。这意味着任何Bird 的子类将会实现制度构造器，所以就意味着它们放弃了构造器继承，必须实现required构造器并且标记required。<br>上面提到的和现实中iOS编程一个令人烦恼的特性密不可分。比如，你subclass了内置的Cocoa类 UIViewController（你很可能这么做），然后你给了这个子类一个构造器（你很可能这么做）：</p>
<p>22<br>这个代码就不会编译。编译错误显示：required initializer init(coder: ) must be provided by subclass of UIViewController.<br>我们现在就知道其中的缘故了：UIViewController采用了一个NSCoding 的协议，而这个协议需要一个构造器 init(coder: )。这都不是你造成的，UIViewController 和NSCoding都是Cocoa定义的。但是这不碍事，这就是我刚刚提到的情形。你的UIViewController子类要不就是继承了init(coder:) 要不必须显式实现它并且标记required。既然你的子类已经有了一个指定构造器，那么继承就泡汤了，只能用后者了。<br>但是如果你压根儿没想过要实现这么个构造器，再这样操作这就显得没有意义了。Xcode的Fix-It特性提供了下面的方法：</p>
<p>23<br>它既满足了构造器（在c5，会有为什么即使他没有完成条件，但依然是合法构造器的原因），又使得他在被调用的时候会自动crash。<br>如果你真的有要实现的东西，那么只需要删除fatalError 一行，并且用你自己的代码代替就可以了。最小的实现内容就是super.init(coder: aDecoder)，当然如果你有需要初始化的属性，你也可以先初始化它们。<br>不仅UIViewController，还有很多Cocoa的内置类都采用了NSCoding。如果你有它们的子类并且要自己初始化构造器，那么会经常遇到这个问题。<br>字面转换：<br>Swift中的一个非常好的点就是：它的很多特性是在内部实现的而且在头文件中可以看到。Literal就是一例。比如你可以直接写出5来制造一个值为5的Int（而不需要很正式地写Int(5)）不是因为玄学，而是因为Int采用了IntegerLiteralConvertible协议。不只是Int Literal 是这样工作，其他Literal也是这样的原理。下面是在Swift头文件中定义的literal convertible protocol：</p>
<p>24<br>你自己的对象类型也可采用上面的转换协议。这意味着literal可以出现在你的对象类型实例可以出现的地方。<br>比如我们定义一个Nest类型，其中包括鸡蛋个数变量：</p>
<p>25<br>因为Nest采用了IntegerLiteralConvertible，我们可以将Int传至Nest可以用的地方，然后init(integerLiteral：)就会被自动调用，从而产生一个新的Nest对象包含特定的鸡蛋数。</p>
<p>26</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协议&lt;br&gt;协议是一种表示类型的相通性的方法，往往这些类型某些方面迥异。比如，一个Bee对象和一个Bird对象就在飞行方面有共同之处。因此定义一个Flier类型就很有用。问题来了：在哪种意义上，Bee和Bird可以算Flier呢？&lt;br&gt;除了继承，当然一个可能的选择是类继承
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类型引用</title>
    <link href="http://yoursite.com/2017/06/09/iosrefer/"/>
    <id>http://yoursite.com/2017/06/09/iosrefer/</id>
    <published>2017-06-09T03:10:31.000Z</published>
    <updated>2017-06-09T03:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个实例来说，引用自身的类型是很有用的。比如向此类型传递消息。在之前的一个例子中，一个Dog实例方法通过消息显式传递将一个Dog类型属性取回。</p>
<p>1<br>Dog.whatDogSay这样的表达方式看起来很笨拙而且一点也不灵活。为什么我们必须将代码写死？它是一个类，它应该知道自己的情况。<br>在Oc里，你可能已经习惯了使用类的实例方法解决这种情况。在Swift里，一个实例可能不是一个类，而是结构体或者枚举。swift实例有的是一个类型。对于这种目的，swift提供的实例方法中是动态类型方法。一个实例可以到达它的类型中，通过这种方法。因此，如果你不喜欢Dog类实例调用类方法通过显式“说”Dog这种方法，这里还有一个另外的方法：</p>
<p>2<br>使用动态类型而非写死（hard-cording），一个重要的事情就是它遵循多态。</p>
<p>3<br>现在看看会发生什么？</p>
<p>4<br>像这样，我们告诉NoisyDog实例去bark，他就会说三次。其中的原因就是dynamicType：这个类型是实例事实是的那个类型。这就把这个类型变得动态了。我们把bark消息传递给NoisyDog实例。bark的实施指向这个实例，所救取出了三次“Woof”。<br>Tips: 你可以使用print(myobject.dynamicType)来输出对象类型，它会直接以字符串的形式输出。这对debug很有帮助。<br>在某些情况下，你可能想要将对象类型传递作一个变量。这是可以实现的，一个对象类型就是一个对象，下面是一些你需要知道的：<br>1、去声明可接受的对象类型——比如就像变量或者参数的类型，使用点运算符以及类型名和Type关键字。<br>2、将对象类型作为值来使用，比如，将类型赋给变量或者传给函数；使用类型的引用（类型名，或一些实例的dynamicType），很可能后面有self关键字和点号。<br>比如，下面这个函数接受Dog作为参数：</p>
<p>5<br>下面是一个调用该函数的例子：</p>
<p>6<br>或者还可以这样调用：</p>
<p>7<br>为什么要这么做呢？一个典型的情况就是这个函数就像实例的加工厂：给他一个类型，它创建一个这种类型的实例，对它再加工一番，然后返回它。通过发送init(…)消息，你可以用一个变量引用这个类型去制作一个这种类型的实例。<br>比如，下面是一个Dog类型包含init(name:)构造器，和它的子类NoisyDog：</p>
<p>8<br>下面是一个加工厂函数：制作一个Dog或者NoisyDog，给他一个名字，再返回它：</p>
<p>9<br>就像你看到的，由于whattype指向一个类型，我们可以调用它的构造器去制作一个该类型的实例。然而出了一些问题，原因是编译器不清楚init(name: )是不是所有的Dog的子类都有。为了是编译器“安心”，我们必须声明构造器为required构造器：</p>
<p>10</p>
<p>之前我保证过，我已经告诉你为什么你要用required构造器，现在我遵守了承诺。required指定构造器是编译器安心，因为每个子类都必须继承或者重写init(name:) 所以发送给Dog或者其子类的对应类型是合法的。现在代码就可以用了。我么你可以调用上面的函数：</p>
<p>11<br>在类的方法中，self代表这个类——多态地。这意味着在这个类的方法中，你可以发送消息给self去多态地调用构造器。请看这个例子：如果我们想要把之前的加工厂函数以类方法内嵌到类中，叫做makeAndName。我们想要这个类方法，无论我们发送消息给什么类，都会制造和返回一个有名字对应类的Dog。也就是说我们说Dog.makeAndName()，我们会得到一个Dog实例，我们说NoisyDog.makeAndName()，我们就会得到一个NoisyDog类。这种类型是多态的self类型，所以我们的makeAndName类方法初始化self：</p>
<p>12<br>结果是这样的：</p>
<p>13<br>但是这里有个问题。虽然d2事实上是一个NoisyDog，但是他的类型是Dog。这是因为该类方法声明返回一个Dog类。这恰恰不是我们想要的。我们想表达的是，返回一个与该方法调用者一样的类。也就是说，我们需要一个多态式的类型声明。这个类型就是Self（注意大写）。在这里，它被用作一个返回值，表示：返回一个它实际上类型的实例。</p>
<p>14<br>现在当我们调用NoisyDog.makeAndName()的时候，我们就会得到一个NoisyDog类型的NoisyDog。Self也对实例方法声明有效。因此，我们可以为我们的加工厂函数写一个实例方法。这里我们以一个Dog或者NoisyDog开始，并告诉它有一个和它一样类型的小狗：</p>
<p>15<br>测试一下它：</p>
<p>16<br>就像预想的一样，d2是Dog. nd2是NoisyDog。<br>为了不被搞糊涂，还是弄一个Summary：<br>.dynamicType:<br>用在代码中，发送给实例：只要是该实例内部的可多态的类型就可以，不论实例引用的类型是什么。而且通过实例的dynamicType，Static/Class成员是可以get到的。<br>.Type:<br>用在声明中，发送给类型：可多态的类型（与该类型的实例相反）。比如，在一个函数声明中，Dog代表需要一个Dog类，但是Dog.Type代表类型本身。（这样才能调用类型方法嘛！）<br>.self:<br>用在代码中，发送给类型。比如，将Dog类型传递到需要Dog.Type的地方，比如Dog.self（传递.self 给实例不是非法的，但是毫无意义）。<br>self:<br>在实例代码中，这个实例是多态的。<br>在Static/Class代码中，也是多态的；self.init(…)初始化了这个类型。<br>Self:<br>用在方法声明中，当具体说明返回值类型，该类或者实例的类，可多态的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个实例来说，引用自身的类型是很有用的。比如向此类型传递消息。在之前的一个例子中，一个Dog实例方法通过消息显式传递将一个Dog类型属性取回。&lt;/p&gt;
&lt;p&gt;1&lt;br&gt;Dog.whatDogSay这样的表达方式看起来很笨拙而且一点也不灵活。为什么我们必须将代码写死？它是
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 转型 Casting</title>
    <link href="http://yoursite.com/2017/06/09/ioscast/"/>
    <id>http://yoursite.com/2017/06/09/ioscast/</id>
    <published>2017-06-09T03:09:25.000Z</published>
    <updated>2017-06-09T03:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于Swift严格的类型检查，其编译器在规定什么样的消息可以发送给对象引用实行严格的限制。被允许发送给对象引用的消息是那些已经被引用的声明类型所允许的消息，其中包括它的继承。<br>由于多态的内部识别原则，这意味着一个对象可能有能力接受编译器原先不允许的消息。这对我们是一个严重的约束。<br>转型（casting）可以很好地解决这个问题。<br>把as关键字加在你想要的真正类型名之前，就可以实现转型。Swift不允许在原有的类型之间转型（Int ->String），但是把父类转型为子类是允许的，这叫做向下转型（Casting Down）。as！表示向下转型。！就是提醒你，向下转型是强制编译器做一些她不想做的事情。</p>
<p>1<br>这段代码成功编译。这个例子还能以下面这种方便的方式表达：</p>
<p>2<br>这种方式更方便的原因是：防止有其他的NoisyDog消息需要传送到对象。我们可以定义一个值，并且downcasting给它。现在这个值被推断为转型后的值，这样就可以多次调用，而切不用多次转型了。<br>as！的！同时也是在警示这个代码可能崩溃。这是因为我们有可能误导编译器。Casting Down是告诉编译器放松严格类型限制检查，这样即使你转型出错，编译器也有可能放行，但在App运行的时候会崩溃。</p>
<p>3<br>这个例子中，我们告诉编译器这个对象将会是一个NoisyDog，于是编译器就放开手让我们操作，然而事实上，这个对象却是一个Dog类型，由此这段代码的运行结果就是  崩溃。<br>为了避免这种情况，你可以在实例运行的时候启用检查机制。一种方式就是使用is关键字。你可以使用is在一个条件语句中，如果通过检查，就可以继续转型了。</p>
<p>4<br>这样，我们就会只在是NoisyDog的情况下转型了。<br>另一种方法则是使用as？关键字。这样转型的结果就是一个可选类型。</p>
<p>5<br>这看起来不是那么的简洁。所以我们运用可选解包，将代码进一步精简：</p>
<p>6<br>首先，我们使用as？运算符获得一个可选值（包含NoisyDog或者只是nil）。然后我们可选解包并且传入消息。如果传入的d不是NoisyDog，那么可选值是nil，则消息不会被传入。如果d是NoisyDog，那么他会被解包并且传入消息。所以说，这段代码是安全的。<br>回想之前的可选值的会自动解包来比较，as! as? is运算符也是一样的。</p>
<p>7<br>如果这个可选值是一个nil，那么这个检查会有条不紊的结束。事实上，这个检查做了两件事情：可选值是不是nil？如果不是其包含的值是不是符合要求？<br>可选值怎样进行转型呢？事实上你不能真正地将可选值进行转型，但是你可以使用as!，因为Swift明白你要做什么。当在as!前面的是一个可选值，Swift会把它当成其解包后的值。也就是说，as!运算符应用的结果就是：Swift先进行了解包，再进行转型。</p>
<p>8<br>然而这段代码是不安全的，没有进行检查，你不应该像这样进行转型，除非你很确定。如果d是nil，你将会在第二行崩溃，因为你在强制把nil解包。而如果d是一个Dog，你也会由于cast失败而面临崩溃。这就是为什么会有as?运算符，虽然生成了可选值但是更加安全。</p>
<p>9<br>另一种你需要运用转型的情况是在进行Swift<br>和Oc进类型相似的值交换的时候。比如说，你可以把String 转为NSString，反之也可。这不是因为他们是父类子类，而是因为它们之间进行了桥接。在某种意义上，它们是相同类型，所以这不是向下转型（cast down），所以也没有什么危险，就可以直接用as。</p>
<p>10<br>这个as就是告诉s待在Cocoa的世界里，来调用rangeOfString方法，因此他所产生的结果也是NSRang而不是一个Swift range。<br>这种桥接大量存在于此。经常地，你不需要进行这种转型，因为Swift会自动帮你完成。比如，Swift的Int和Cocoa的NSNumber是两个很不同的类型，但是尽管如此你还是可以常常地在要求NSNumber的地方使用Int。</p>
<p>11<br>在这个代码中，我们使用了1这个Int值，事实上这里需要的是NSObject的实例。Int不仅不是NSObject而且还不是类的实例（它是一个结构体实例）。Swift会自动桥接转型，将Int变为NSNumber。<br>另一种情况，当你调用一个objectForKey：的时候，swift不知道该值究竟是什么类型的，所以你必须显式转型为Int。</p>
<p>12</p>
<p>ud.objectForkey(“Test”)会产生一个包含整数的NSNumber，所以转为Swift的Int类型是允许的。但是如果产生的不是一个NSNumber或者是一个nil，程序就会崩溃。如果你不太确定，还是使用is或者as?会比较安全。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于Swift严格的类型检查，其编译器在规定什么样的消息可以发送给对象引用实行严格的限制。被允许发送给对象引用的消息是那些已经被引用的声明类型所允许的消息，其中包括它的继承。&lt;br&gt;由于多态的内部识别原则，这意味着一个对象可能有能力接受编译器原先不允许的消息。这对我们是一个
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类的属性和方法</title>
    <link href="http://yoursite.com/2017/06/09/classpropertymethod/"/>
    <id>http://yoursite.com/2017/06/09/classpropertymethod/</id>
    <published>2017-06-09T03:05:57.000Z</published>
    <updated>2017-06-09T03:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>子类可以重写他所继承得到的属性。重写必须是 属性名与属性类型一样 而且要加override前缀。子类的新属性不能有与继承属性一样的名，除非是不同类型的属性。下面的这些规则也同样适用：</p>
<p>1、如果父类的属性是可写入的（一个存储属性或者一个带着setter的计算属性），那么子类的重写可以增加一个属性观察者。<br>2、或者子类的重写的是计算属性。这种情况下，如果父类的属性是存储属性，子类的计算属性重写必须包含setter和getter。<br>如果父类的属性是计算属性，子类的计算属性重写必须重新实现父类实现的所有访问器（accessor）；如果父类属性是只读的（只有getter），那么重写可以添加setter。</p>
<p>重写的属性包含的函数可能会引用（读取或者写入）被继承的属性，这可以通过super关键字实现。</p>
<p>就像结构体和枚举类型，类可以拥有static成员，也可以有class成员。这两种成员都会被继承到子类中（也是static和class 的形式）。<br>从开发者的角度来看，标记了static和class的方法最主要的差别在于static方法不能被重写。也就是说：static与class final同义。<br>static与class属性的区别类似，不过有一点需要增加，是一个比较严苛的条件：static属性可以是存储属性和计算属性，而class属性只能是计算属性。<br>class 标记属性的时候，只能是计算属性。子类继承了该计算属性，并且可以重写它（无论是写作class还是static都可以），但是如果要标记为为static，不能重写成存储属性，这是为了遵循之前提到的继承规则。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;子类可以重写他所继承得到的属性。重写必须是 属性名与属性类型一样 而且要加override前缀。子类的新属性不能有与继承属性一样的名，除非是不同类型的属性。下面的这些规则也同样适用：&lt;/p&gt;
&lt;p&gt;1、如果父类的属性是可写入的（一个存储属性或者一个带着setter的计算属性
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类的析构器</title>
    <link href="http://yoursite.com/2017/06/09/iosdeinit/"/>
    <id>http://yoursite.com/2017/06/09/iosdeinit/</id>
    <published>2017-06-09T03:03:14.000Z</published>
    <updated>2017-06-09T03:05:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的析构器："><a href="#类的析构器：" class="headerlink" title="类的析构器："></a>类的析构器：</h1><p>_只有类才有析构器。<br>这个函数是在大括号前添加deinit关键字来构成的。<br>你不能主动调用这个函数，当这个类的实例销毁之前析构器会被自动调用。如果这个类是其他类的子类，子类的析构器将会在父类的析构器之前被调用。<br>析构器的用处是：清除或者在console中显示某个实例已经被正常销毁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类的析构器：&quot;&gt;&lt;a href=&quot;#类的析构器：&quot; class=&quot;headerlink&quot; title=&quot;类的析构器：&quot;&gt;&lt;/a&gt;类的析构器：&lt;/h1&gt;&lt;p&gt;_只有类才有析构器。&lt;br&gt;这个函数是在大括号前添加deinit关键字来构成的。&lt;br&gt;你不能主动调用这个函
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 多态</title>
    <link href="http://yoursite.com/2017/06/09/iosduotai/"/>
    <id>http://yoursite.com/2017/06/09/iosduotai/</id>
    <published>2017-06-08T16:19:44.000Z</published>
    <updated>2017-06-08T16:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>多态：<br>如果一个计算机语言有类型和子类型的等级体系，它必须解决一个问题： 这种体系对于 对象类型和引用这个对象的东西的类型的关系 意味着什么？Swift遵循多态原则。在我看来多态是一个面向对象语言成熟的关键。下面我们归纳一下Swift的多态原则：<br>代替性：在某个类型可用的地方，它的子类型也可以用。<br>内部识别：对象类型是其内部特性，无论该对象被怎样引用 都不会变。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态：&lt;br&gt;如果一个计算机语言有类型和子类型的等级体系，它必须解决一个问题： 这种体系对于 对象类型和引用这个对象的东西的类型的关系 意味着什么？Swift遵循多态原则。在我看来多态是一个面向对象语言成熟的关键。下面我们归纳一下Swift的多态原则：&lt;br&gt;代替性：在某个
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类的构造器（五）</title>
    <link href="http://yoursite.com/2017/06/09/iosinit5/"/>
    <id>http://yoursite.com/2017/06/09/iosinit5/</id>
    <published>2017-06-08T16:16:15.000Z</published>
    <updated>2017-06-08T16:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>要求构造器：<br>对于类的构造器还有一件事要说明：前缀为required的构造器。这意味着子类不能遗漏它。而这接下来就意味着如果一个子类使用指定构造器（这样会阻碍继承），它必须重写这个构造器（required）。一个例子：</p>
<p>1</p>
<p>这段代码无法编译。我们需要继承或者重写标记有required的构造器。由于，我们要引入新的Boolean值，因此不能采取继承的方法。所以我们要重写它：</p>
<p>2<br>上例中，被重写的required构造器并没有被override标记，而是被required标记，这说明required将会继续在NoiseDog的子类中继续传递。<br>以上是怎样制造一个要求构造器，下面我将谈谈为什么要制造要求构造器。</p>
<p>Cocoa带来的意外：<br>当你在subclassing某种Cocoa类的时候，构造器继承规定可能会导致一些意料之外的事情。比如，在进行iOS开发的过程中，你肯定会声明一个UIViewController的子类，let’s say，你为你的子类设置一个指定构造器。这个指定构造器在父类（UIViewController）中是init(nibName:bundle:)，所以，遵照规定，你调用了此构造器：</p>
<p>3<br>看起来还不错，但是你然后就会发现在别处的代码出现了问题：使得ViewController 实例不再编译了。</p>
<p>4<br>在写下指定构造器之前这段代码是合法的；现在则非法。原因在于在子类中使用指定构造器，将阻碍构造器继承，你需要重写该构造器（init(nibName:bundle)），即使你已经你在子类中调用过它。</p>
<p>5<br>这样图4中的实例就可以顺利编译了。<br>然而现在又有一个意外：ViewController 无法编译了。原因在于：有一个要求（required）构造器在ViewController中。所以你必须使用它。而你之前不了解它，因为当ViewController没有显式构造器，你继承了要求构造器；现在你又阻碍了继承。幸运的是，Xcode的Fix-It功能提供了stub运用。他不会做任何事（甚至调用它，程序将会崩溃），但是它使得程序可以编译：</p>
<p>6<br>在之后的章节中我会讲解这个要求构造器如何被使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要求构造器：&lt;br&gt;对于类的构造器还有一件事要说明：前缀为required的构造器。这意味着子类不能遗漏它。而这接下来就意味着如果一个子类使用指定构造器（这样会阻碍继承），它必须重写这个构造器（required）。一个例子：&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;这段代码无法编译
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类的构造器（四）</title>
    <link href="http://yoursite.com/2017/06/09/iosinit4/"/>
    <id>http://yoursite.com/2017/06/09/iosinit4/</id>
    <published>2017-06-08T16:15:15.000Z</published>
    <updated>2017-06-08T16:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>可失败构造器（Failable initializers）：<br>直到一个可失败构造器完成了它所有的初始化任务，它才可以：return nil。因此，比如一个可失败子类构造器必须在所有的子类属性被初始化和调用super.init( ) 之后才可以return nil。（这里有一个有趣的讽刺：在销毁实例之前，构造器必须完成建立实例；但是，为了保证父类有一个清晰的的初始化，这个工作又是必须的。）<br>如果一个被可失败构造器调用的构造器是可失败的，这个调用语法不会改变，并且也不需要其他的检查——如果一个被调用的可失败构造器失败了，那么整个初始化进程将立刻失败并终止。<br>对于重写与代理，一个返回隐式解包（init!）的可失败构造器与正常构造器被一样对待。对于返回可选值的可失败构造器(init?)，这里有一些额外的限制要求：<br>1、init可以重写init? ， 反之不可以<br>2、init?可以调用init<br>3、init可以调用init? （通过使用init并！解包，如果用？，失败情况会导致程序崩溃）<br>具体见下示例：</p>
<p>Image A<br>TIPS：<br>子类构造器绝不可以为父类设置常量（let），这是因为在允许子类做 除了不能初始化自己的属性和调用另一个构造器之外 所有事 的时候，父类已经完成了自身的初始化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可失败构造器（Failable initializers）：&lt;br&gt;直到一个可失败构造器完成了它所有的初始化任务，它才可以：return nil。因此，比如一个可失败子类构造器必须在所有的子类属性被初始化和调用super.init( ) 之后才可以return nil。（这
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类的构造器（三）</title>
    <link href="http://yoursite.com/2017/06/09/iosinit3/"/>
    <id>http://yoursite.com/2017/06/09/iosinit3/</id>
    <published>2017-06-08T16:15:12.000Z</published>
    <updated>2017-06-08T16:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>重写构造器：<br>在子类中，父类的构造器是可以被重写的，并且依照如下的规定：<br>1、Signature与父类的便利构造器相配的构造器 必须是一个便利构造器而且不能被override标记。<br>2、Signature与父类的指定构造器相配的构造器 可以是一个指定构造器也可以是一个便利构造器，而且必须被override标记。父类的指定构造器(被重写的构造器通过super.init( )调用的)可以是那个被重写的那个构造器。<br>Tips：<br>A. Signature就是标识方法的签名。<br>B. 2的后一句意思就是即使父类的某个方法被重写，他依然可以被调用。<br>通常，如果一个子类有任何指定构造器，那么它不会继承任何父类的构造器。但是如果一个子类重写了它父类的所有指定构造器，那么它将继承所有的便利构造器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重写构造器：&lt;br&gt;在子类中，父类的构造器是可以被重写的，并且依照如下的规定：&lt;br&gt;1、Signature与父类的便利构造器相配的构造器 必须是一个便利构造器而且不能被override标记。&lt;br&gt;2、Signature与父类的指定构造器相配的构造器 可以是一个指定构造器
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类的构造器（二）</title>
    <link href="http://yoursite.com/2017/06/09/iosinit2/"/>
    <id>http://yoursite.com/2017/06/09/iosinit2/</id>
    <published>2017-06-08T16:15:09.000Z</published>
    <updated>2017-06-08T16:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>子类的构造器<br>在阐明和辨别清楚指定构造器和便利构造器之后，我们就可以开始了解子类的构造器了。<br>未声明构造器：<br>如果子类不是必须有它自身的构造器，并且如果它没有声明自身的构造器，那么它继承父类的构造器。<br>只有便利构造器：<br>如果子类不是必须有它自身的构造器，它是有资格声明便利构造器的，因为继承提供了便利构造器所需要的指定构造器。<br>指定构造器：<br>如果子类定义了自身的指定构造器，整件事情就不一样了。<br>这种情况下，构造器就不被继承了。显式指定构造器的存在阻碍了构造器的继承。现在子类的构造器就只有显式指定的构造器了。（还有一个例外将在一会儿讲解）<br>每一个子类的指定构造器现在有一个额外的要求：它必须通过super.init( )调用一个父类的指定构造器。此外，调用self 的规则依然适用。一个子类的指定构造器必须按照如下的顺序和要求：<br>1、它必须保证这个子类的所有属性均被初始化。<br>2、它必须调用super.init( )并且这个被调用的构造器必须是指定构造器<br>3、现在，它才可以使用self去干别的事情：调用实例方法或者获取继承的属性。<br>子类中的便利构造器还是应该遵守先前提到的规则。他们必须调用self.init( )来直接或者间接地调用一个指定构造器。在没有继承构造器的情况下，便利构造器调用的构造器必须是在子类中出现的。<br>WARNING：<br>如果一个指定构造器不调用super.init(…)，那么如果可能，super.init(…)将被隐式调用。下面的代码是合法的：<br>class Cat  {<br>     }<br>class NamedCat : Cat  {<br>         let name : String<br>         init(name:String) {<br>                 self.name = name<br>             }<br>     }<br>在我看来，这个swift特性是一个错漏。swift不应该纵容这种隐蔽的方法，即使它可能是“有帮助的”。我觉得这段代码不应该可以编译。一个指定构造器始终必须显式调用super.init(…)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;子类的构造器&lt;br&gt;在阐明和辨别清楚指定构造器和便利构造器之后，我们就可以开始了解子类的构造器了。&lt;br&gt;未声明构造器：&lt;br&gt;如果子类不是必须有它自身的构造器，并且如果它没有声明自身的构造器，那么它继承父类的构造器。&lt;br&gt;只有便利构造器：&lt;br&gt;如果子类不是必须有它自身
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS9 with Swift 类的构造器（一）</title>
    <link href="http://yoursite.com/2017/06/09/iosinit1/"/>
    <id>http://yoursite.com/2017/06/09/iosinit1/</id>
    <published>2017-06-08T16:09:47.000Z</published>
    <updated>2017-06-08T16:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>隐含构造器：<br>如果一个类，或是没有存储属性，或是已经初始存储属性在声明中，并且没有显式构造器，那么它就含有一个隐含构造器init( )。<br>指定构造器：<br>默认情况下，类的构造器是指定构造器。<br>只要一个类含有“没有在声明中初始化的存储属性”，那么这个类至少需要一个指定构造器。而且当这个类产生实例的时候，必须调用这些指定构造器中的一个，以初始化所有的储存属性。一个指定构造器可能不会委托此类中的其他构造器；对于指定构造器，使用self.init(…)是不合法的。<br>便利构造器：<br>关键字 convenience来标记便利构造器。<br>它是一个委托构造器。所以必须包含self.init(…)。<br>其必须调用一个本类中的指定构造器，或者本类中的便利构造器（这样就形成了构造器链），不管如何链的最后需要一个指定构造器来结束。<br>//… 例子略<br>应该注意到：一个构造器可以“说”什么和什么时候“说”的规则依然适用。一个指定构造器除初始化属性外不可以调用self，除非该类的所有属性已经初始化完毕。而便利构造器是一个委托构造器，所以直到它调用完一个指定构造器才能使用self（而且不能够设置一个不可改变属性）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;隐含构造器：&lt;br&gt;如果一个类，或是没有存储属性，或是已经初始存储属性在声明中，并且没有显式构造器，那么它就含有一个隐含构造器init( )。&lt;br&gt;指定构造器：&lt;br&gt;默认情况下，类的构造器是指定构造器。&lt;br&gt;只要一个类含有“没有在声明中初始化的存储属性”，那么这个类至
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>写在博客建立之时的话</title>
    <link href="http://yoursite.com/2016/06/08/blog/"/>
    <id>http://yoursite.com/2016/06/08/blog/</id>
    <published>2016-06-08T15:52:13.000Z</published>
    <updated>2017-06-08T16:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一切会安好"><a href="#一切会安好" class="headerlink" title="一切会安好"></a>一切会安好</h1><p>看着你看窗外悄悄变红的夜<br>轻轻的你的手又握紧了一些<br>该不该让你到我的世界<br>let’s start from here 无所谓慢慢来<br>迷宫一样的未来转一个圈<br>会到哪里我喜欢爱情有点神秘<br>i don’t care where we go<br>let’s start from here<br>陪着我喝咖啡爱在空气里<br>暖暖的是你的笑赶走心情的灰<br>我想我不在意你曾爱过谁<br>let’s start from here<br>无所谓就算爱像空沙发在等待<br>拥抱着是不确定我喜欢爱情多点惊喜<br>i don’t care where we go<br>let’s start from here<br>let’s start from here<br>爱一个人怎么开始啊像街上走过那些人们<br>转一个弯预见美好<br>start from here<br>无所谓慢慢来迷宫一样的未来<br>转一个圈会到哪里我喜欢爱情有点神秘<br>无所谓就算爱像空沙发在等待<br>拥抱着是不确定我喜欢爱情多点惊喜<br>i don’t care where we go<br>let’s start from here um…<br>let’s start from here oh…<br>let’s start from here<br>let’s start from here</p>
<p>\<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5247172&auto=1&height=66" align="“middle”\"> \</iframe></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一切会安好&quot;&gt;&lt;a href=&quot;#一切会安好&quot; class=&quot;headerlink&quot; title=&quot;一切会安好&quot;&gt;&lt;/a&gt;一切会安好&lt;/h1&gt;&lt;p&gt;看着你看窗外悄悄变红的夜&lt;br&gt;轻轻的你的手又握紧了一些&lt;br&gt;该不该让你到我的世界&lt;br&gt;let’s start 
    
    </summary>
    
    
  </entry>
  
</feed>
